#!/bin/bash
# bash script to deploy Gitlab cluster in kubernetes.
# Run this bash file manually to deploy Gitlab( Gitlab ce, gitlab runner, Nexus registry), after creating the cluster with the create_cluster.sh.

ARCH=${ARCH:-arm64}

export KUBECONFIG=~/.kube/k3s-config

# Create CA private key
openssl genrsa -out ca.key 4096

# Create a certificate signing request (CSR)
openssl req -new -x509 -key ca.key -out gitlab-cert.crt -days 365 -subj "/CN=*.local"

# Create a PEM file from the CRT file
cp gitlab-cert.crt gitlab-cert.pem

# TLS certs should be generated by this stage, including CA and GitLab certs to secure https gitlab url
echo "Certificates generated: ca.key, gitlab-cert.crt, gitlab-cert.pem"

# Deploy GitLab using Helm
helm repo add gitlab https://charts.gitlab.io/
helm repo add sonatype https://sonatype.github.io/helm3-charts/
helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/
helm repo add minio https://charts.min.io/
helm repo update

kubectl create namespace gitlab 2>/dev/null || true
kubectl create namespace gitlab-runner 2>/dev/null || true
kubectl create namespace kubernetes-dashboard 2>/dev/null || true
kubectl create namespace minio 2>/dev/null || true

kubectl create secret tls gitlab-tls --cert=gitlab-cert.crt --key=ca.key -n gitlab 2>/dev/null || true
kubectl create secret tls kubernetes-dashboard-certs --cert=gitlab-cert.crt --key=ca.key -n kubernetes-dashboard 2>/dev/null || true
kubectl create secret generic gitlab-ca --from-file=ca.pem=gitlab-cert.crt -n gitlab-runner 2>/dev/null || true

# Since Gitlab requires minio, Deploy external MinIO compatible, Note I am using M4 MacBook Pro so deploy minio for ARM64
helm install minio minio/minio \
  --namespace minio \
  --set mode=standalone \
  --set persistence.enabled=true \
  --set persistence.size=1Gi \
  --set rootUser=admin \
  --set rootPassword=admin123 \
  --set image.repository=minio/minio \
  --set image.tag=RELEASE.2024-06-13T22-53-53Z \
  --set resources.requests.memory=256Mi \
  --set resources.limits.memory=512Mi

# Create the bucket for GitLab
kubectl wait --for=condition=ready pod -l app=minio -n minio --timeout=120s

if [ "$ARCH" = "amd64" ]; then
  MC_URL="https://dl.min.io/client/mc/release/linux-amd64/mc"
else
  MC_URL="https://dl.min.io/client/mc/release/linux-arm64/mc"
fi
command -v mc >/dev/null || { mkdir -p ~/bin; curl -sSL "$MC_URL" -o ~/bin/mc; chmod +x ~/bin/mc; export PATH="$HOME/bin:$PATH"; }

MINIO_POD=$(kubectl get pods -n minio -l app=minio -o jsonpath="{.items[0].metadata.name}")
kubectl port-forward -n minio $MINIO_POD 9000:9000 &
PF_PID=$!
sleep 3
mc alias set minio-local http://localhost:9000 admin admin123
mc mb --ignore-existing minio-local/gitlab
kill $PF_PID

# Create the MinIO connection secret for GitLab (object storage)
cat <<EOF > minio-connection.yaml
provider: AWS
aws_access_key_id: admin
aws_secret_access_key: admin123
region: us-east-1
endpoint: http://minio.minio.svc.cluster.local:9000
path_style: true
EOF

kubectl delete secret gitlab-minio-credentials -n gitlab --ignore-not-found
kubectl create secret generic gitlab-minio-credentials \
  --from-file=connection=minio-connection.yaml \
  -n gitlab

# Deploy GitLab connected to external MinIO
helm install gitlab gitlab/gitlab \
  --namespace gitlab \
  --set global.hosts.domain=local \
  --set certmanager.install=false \
  --set global.ingress.configureCertmanager=false \
  --set global.ingress.class=nginx \
  --set global.ingress.tls.secretName=gitlab-tls \
  --set nginx-ingress.enabled=false \
  --set gitlab-runner.install=false \
  --set registry.enabled=false \
  --set global.edition=ce \
  --set global.minio.enabled=false \
  --set global.appConfig.object_store.enabled=true \
  --set global.appConfig.object_store.connection.secret=gitlab-minio-credentials \
  --set global.appConfig.object_store.connection.key="" \
  --set global.appConfig.object_store.storage_options.endpoint=http://minio.minio.svc.cluster.local:9000 \
  --set global.appConfig.object_store.storage_options.region=us-east-1 \
  --set global.appConfig.object_store.storage_options.bucket=gitlab \
  --set global.appConfig.object_store.storage_options.path_style=true \
  --timeout=600s


# Kubernetes Dashboard so we can view our cluster via web browser
echo "Installing Kubernetes Dashboard..."
helm install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard \
  --namespace kubernetes-dashboard \
  --wait

# Admin user for dashboard
kubectl apply -f - <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard
EOF

sleep 180

kubectl wait --for=condition=ready pod --selector=app=webservice --namespace=gitlab --timeout=300s

ROOT_PASSWORD=$(kubectl get secret gitlab-gitlab-initial-root-password -n gitlab -ojsonpath='{.data.password}' | base64 -d)
RUNNER_TOKEN=$(kubectl get secret gitlab-gitlab-runner-secret -n gitlab -ojsonpath='{.data.runner-registration-token}' | base64 -d)

LB_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

cp gitlab-runner-values-template.yaml gitlab-runner-values.yaml
sed -i '' "s/CLUSTER_IP_PLACEHOLDER/$LB_IP/g" gitlab-runner-values.yaml
sed -i '' "s/\${ARCH}/$ARCH/g" gitlab-runner-values.yaml

helm uninstall gitlab-runner -n gitlab-runner 2>/dev/null || true
sleep 10

helm install gitlab-runner gitlab/gitlab-runner \
  --namespace gitlab-runner \
  --values gitlab-runner-values.yaml \
  --set runnerRegistrationToken="$RUNNER_TOKEN" \
  --set rbac.create=true \
  --set rbac.clusterWideAccess=true

kubectl wait --for=condition=ready pod --selector=app=gitlab-runner --namespace=gitlab-runner --timeout=180s

KUBECONFIG_CONTENT=$(cat ~/.kube/k3s-config)
kubectl create secret generic kubeconfig --from-literal=config="$KUBECONFIG_CONTENT" -n gitlab-runner --dry-run=client -o yaml | kubectl apply -f -

kubectl patch ingress gitlab-webservice-default -n gitlab --type='json' -p='[{"op": "replace", "path": "/spec/rules/0/host", "value": "gitlab.local"}]'

# Remove old entries for gitlab.local and dashboard.local
sudo sed -i '' '/gitlab\.local/d' /etc/hosts >/dev/null 2>&1
sudo sed -i '' '/dashboard\.local/d' /etc/hosts >/dev/null 2>&1

# Add new entries (centralized and idempotent)
{
  echo "$LB_IP gitlab.local"
  echo "$LB_IP dashboard.local"
} | sudo tee -a /etc/hosts >/dev/null

# Dashboard token
DASHBOARD_TOKEN=$(kubectl -n kubernetes-dashboard create token admin-user)

echo ""
echo "GitLab: https://gitlab.local - root:$ROOT_PASSWORD"
echo ""
echo "Kubernetes Dashboard: https://dashboard.local/#/login"
echo ""
echo "  Token: $DASHBOARD_TOKEN"
echo ""
echo "Cluster setup complete!"


